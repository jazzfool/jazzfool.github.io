<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>$ jazzfool.github.io</title><link>/</link><description>Recent content on $ jazzfool.github.io</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 07 Sep 2023 16:56:12 +1000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>How to set up an STM32 development environment, from scratch</title><link>/post/stm32-setup/</link><pubDate>Thu, 07 Sep 2023 16:56:12 +1000</pubDate><guid>/post/stm32-setup/</guid><description>This is an STM32F756ZG Nucleo-144 development board.
When I first started playing with it, I was disappointed by most sources telling you to simply use the STM32CubeIDE (or similar). I don&amp;rsquo;t think you&amp;rsquo;ll actually understand anything about embedded development by using those tools to learn (although they could absolutely be helpful for development speed - but that&amp;rsquo;s not what we&amp;rsquo;re here for).
This guide is mainly for the STM32F7 series, but there&amp;rsquo;s really no reason why you couldn&amp;rsquo;t also use it for other boards with some minor tweaks!</description></item><item><title>Diving into graphics drivers, Part 1</title><link>/post/gfxdrivers-pt1/</link><pubDate>Sun, 30 Jul 2023 16:02:51 +1000</pubDate><guid>/post/gfxdrivers-pt1/</guid><description>Note: This is merely a diary of my journey into graphics drivers. I may get some things wrong here ( email me if this is the case), but it&amp;rsquo;s absolutely worth noting here that I am a complete and utter beginner to graphics driver development.
Motive Why am I getting my hands dirty with graphics drivers? Throughout my entire software development life (mostly as a hobbyist contributing to open-source), I have always tried to find &amp;ldquo;the next thing&amp;rdquo; to challenge myself with.</description></item><item><title>Reconstructing music with genetic algorithms</title><link>/post/phenotune/</link><pubDate>Mon, 24 Jul 2023 19:07:06 +1000</pubDate><guid>/post/phenotune/</guid><description>Introduction I&amp;rsquo;ve been listening to Prefuse 73 and Pogo lately, who are electronic music producers defined by their aggressive use of track sampling in order to create melody and harmony, rather than taking the more &amp;ldquo;direct&amp;rdquo; approach of sampling individual instruments. This creates for very stylistic music where you can almost hear the individual brush strokes of sound - this song a great example of this.
I&amp;rsquo;ve also been looking at some cool projects that perform image/video reconstruction built off of simpler shapes, using a genetic algorithm.</description></item><item><title>3D Outlines in Godot, Part 2</title><link>/post/godot-outlines-pt2/</link><pubDate>Thu, 10 Feb 2022 13:02:00 +1100</pubDate><guid>/post/godot-outlines-pt2/</guid><description>My previous post explained how to implement 3D outlines in Godot using post-processing on top of a custom depth buffer. This works, but is an ugly solution which doesn&amp;rsquo;t look good with large outline widths, and was locked to a single outline color and width globally. It also lacked anti-aliasing as it was a post-process pass presumably running after FXAA.
This new method solves these issues, and is also more performant.</description></item><item><title>3D Outlines in Godot</title><link>/post/godot-outlines/</link><pubDate>Wed, 09 Feb 2022 13:13:22 +1100</pubDate><guid>/post/godot-outlines/</guid><description>This guide was written for Godot 4.0 (Alpha 1 at the time of writing), but does not use any 4.0-specific features
Outlines are a handy visual tool in games to show focus on objects. Unfortunately for Godot, I haven&amp;rsquo;t seen much content on how to make nice looking outlines for 3D objects.
This guide will show you how to make outlines that look like this:
Step 1: Isolating depth Firstly, we need to isolate the depth for the objects we want to outline.</description></item><item><title>Exploring reactive UI</title><link>/post/reactive/</link><pubDate>Sun, 01 Aug 2021 13:49:36 +1000</pubDate><guid>/post/reactive/</guid><description>Past Many are familiar with the practicality of the Qt API. It abides by what most already know of object-oriented programming and manually mutated states. By far the biggest advantage of such an API is its clarity; there is nothing to learn or understand as what you write is exactly what you mean.
int state = 5; // ... QPushButton* add = new QPushButton(this); add-&amp;gt;setLayout(top); display-&amp;gt;setValue(state); connect(add, &amp;amp;QPushButton::pressed, [&amp;amp;]() { state += this-&amp;gt;spinBox-&amp;gt;value(); display-&amp;gt;setValue(state); }); Already we see a flaw however.</description></item><item><title>The grim GUI landscape</title><link>/post/gui/</link><pubDate>Sat, 31 Jul 2021 22:22:55 +1000</pubDate><guid>/post/gui/</guid><description>I&amp;rsquo;d like to think I&amp;rsquo;ve spent long enough in desktop GUI development. I&amp;rsquo;m disappointed by what I&amp;rsquo;ve seen as I&amp;rsquo;ve worked with a vast palette of desktop GUI solutions. Everything from Qt to Electron have their own hideous limbs with their very own creative ways burden you as you develop your app. That isn&amp;rsquo;t to discredit them all, as a few actually offer wonderful developer experiences (though often still lacking in practicality and applicability).</description></item><item><title>Articles</title><link>/articles/</link><pubDate>Thu, 26 Nov 2020 00:00:00 +0000</pubDate><guid>/articles/</guid><description/></item></channel></rss>